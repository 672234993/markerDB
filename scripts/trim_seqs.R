# --------------------------------------
# Process infernal output files (cmscan)
# --------------------------------------


#' Read cmscan output
#'
#' Read the output files of [infernal's](http://eddylab.org/infernal/) cmscan
#' program.  Requires the options --tbleout and --fmt 2.
#'
#' @param filename path to cmscan output file
#' @param filter_by_score filter query id's to keep max score? Defaults to TRUE
#'
#' @importFrom magrittr %>%
#'
#' @export
#'
read_cmscan = function(filename, filter_by_score = TRUE) {

  cols = c(
    "idx", "target_name","target_accession","query_name","query_accession",
    "clan_name","mdl","mdl_from","mdl_to","seq_from","seq_to","strand","trunc",
    "pass","gc","bias","score","E_value","inc","olp","anyidx","afrct1","afrct2",
    "winidx","wfrct1","wfrct2","description_of_target"
  )

  res = read.table(filename, header = FALSE, col.names = cols, comment.char = "#",
             stringsAsFactors = FALSE) %>% tibble::as_tibble()

  if (filter_by_score) {
    res = res %>%
      dplyr::group_by(query_name, target_name) %>%
      dplyr::filter(score == max(score)) %>% dplyr::ungroup()
  }

  return(res)

}


#' Extract ITS region
#'
#' Using the hits identified by cmscan this function takes a data frame created
#' by \code{read_cmscan} filtered to a query of interest along with the sequence
#' of the query and extracts the region likely to be ITS2.  If there are hits to
#' both the 5.8S and 28S (LSU) genes then the region between them is extracted.
#' Otherwise if only one of the hits is identified the region downstream (for
#' the 5.8S) or upstream (for the 28S) is extracted.
#'
#' @param hits dataframe with cmscan hits filtered to a single query
#' @param seq DNAString object, which should be the query sequence matching the
#'   hits dataframe
#' @param extend numeric, the number of basepairs to extend the extracted
#'   region, up and downstream.
#'
#' @return DNAString object
#'
#' @export
extract_ITS = function(hits, seq, extend = 0) {

    start = hits$seq_to[which(hits$target_name == "5_8S_rRNA" )]
    start = start + 1

    end = hits$seq_from[which(hits$target_name == "LSU_rRNA_eukarya" )]
    end = end - 1

    if (length(end) == 0) {
      end = length(seq)
    } else {
      end = end + extend
      if (end > length(seq)) end = length(seq)
    }

    if (length(start) == 0) {
      start = 1
    } else {
      start = start - extend
      if (sign(start) == -1) start = 1
    }

    # 5.8S is at the end - no ITS - return empty DNAString
    if (start > length(seq)) {
      return(Biostrings::DNAString())
    }

    seq[start:end]
}

#' Process all seqs
#'
#' Trim potential ITS2 sequences in a DNStringSet according to hits to the 5.8S and 28S rRNA genes from cmscan
#'
#' @param seqs DNAStringSet with untrimmed potential ITS2 sequences
#' @param cmscan_df dataframe of hits from cmscan, usually generated by \code{\link{read_cmscan}}.
#'
#' @return DNAStringSet with same number of seqs but with trimmed where hits were found
#'
#' @export
process_seqs = function(seqs, cmscan_df, max_width = 700, min_width = 100,
                        return_untrimmed = TRUE) {

  process_single = function(seq, id, cmscan_df, return_untrimmed) {
    id = stringr::str_extract(id, "([^\\s]+)")
    if (id %in% cmscan_df$query_name) {
      hits = dplyr::filter(cmscan_df, query_name == id)
      new_seq = extract_ITS(hits, seq)
    } else if (return_untrimmed) {
      new_seq = seq
    } else {
      new_seq = Biostrings::DNAString()
    }
  }

  # --- trim as needed
  trimmed = purrr::imap(as.list(seqs), ~process_single(.x, .y, cmscan_df, return_untrimmed))

  # --- convert to DNAStringSet
  trimmed = Biostrings::DNAStringSet(trimmed)

  # --- filter to proper lengths and keep only unqiue
  message("Trimming ", sum(Biostrings::width(trimmed) <= min_width), " sequences less than ", min_width )
  trimmed = trimmed[Biostrings::width(trimmed) > min_width]

  message("Trimming ", sum(Biostrings::width(trimmed) >= max_width), " sequences greater than ", max_width )
  trimmed = trimmed[Biostrings::width(trimmed) < max_width]

  trimmed_uniq = unique(trimmed)
  message("Removed ", length(trimmed) - length(trimmed_uniq), " non-unique sequences")
  return(trimmed_uniq)
}



